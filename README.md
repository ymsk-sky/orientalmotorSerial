# ModbusによるPLC経由でのモータ制御
オリエンタルモーターAZシリーズをシリアルで動作させる。


# ModbusTest.py
コピペしました。
Qiita [Modbusを使ってPLC経由でモータを制御する](https://qiita.com/ToyoshiMorioka/items/8f92121f6bf6b9b6d9a0)

COMポートは都度書き換えること。
シリアル変換ケーブルUSB-RS485-WEを使用すると以下のようになる。

```
port = '/dev/tty.usbserial-FT1GOG9N'
```

# 主に使用するファイル
- py_control.py
- robot_control.py
- demo_movement.py
- electromagnetic_brake_test.py

## py_control.py
メインファイル → robot_contorol.pyに移行

モータードライバとマイコンと同時にシリアル通信を行なう。
マイコンとの通信によってセンサ値をreadしその値に応じてモーターの回転角度を決定する。
モーターは動作前に状態の確認を行ない、動作中であれば待機、動作可能になるとクエリ作成・書き込み・レスポンス読み出し、の処理を行なう。

## robot_control.py
モータードライバとマイコンと同時にシリアル通信を行なう。
py_control.pyに電磁ブレーキの制御を追加。

## demo_movement.py
2019年3月15日の合同説明会のデモ動作用に作成。

動作を変更することで4つのデモ動作を行なう。

（189行目のforループのdirect_query_listXを変更する）

#### direct_query_list1
左右の足を前後に振る「前後動作」。
使用するモーターは前後用と足首用の計4つ。
前に出した足側の足首を縮め、後ろに出した足側の足首を伸ばすようにアクチュエータを回す。

#### direct_query_list2
適当な位置に両足を交互に移動させる「擬似ふらつき動作」。
list1と同様に動かす足側の足首を縮め、軸足側の足首を伸ばすようにアクチュエータを回す。


#### direct_query_list3
両方のアクチュエータのみを正方向、逆方向に交互に回す。

#### direct_query_list4
両方のアクチュエータのみを正方向、逆方向に交互に回す。
list3より多く回転させる。

## electromagnetic_brake_test.py

# 運転方法
オリエンタルモーターModbus RTU制御（RS-485通信）を参照。

マニュアルはHM-60252J.pdf, p.247~

## ダイレクトデータ運転
通常運転より操作できるパラメータが少ないが、書き込みと同時に動作開始する。
パラメータは以下の7項目。
- データNo.
- 方式
- 位置
- 速度
- 起動・変速レート
- 停止レート
- 運転電流

この内、データNo.は0に固定、運転電流は100%に固定のためそれ以外の5つのパラメータを使用する。

## ドライバ出力状態
ドライバI/Oの出力状態を取得しその値に応じて動作を変更する。

### CRC-16/Modbusの計算
実装しました。以下アルゴリズム。

1. 初期値をFFFFhとし、FFFFhと最初のアドレス(8ビット)の排他的論理和(XOR)を計算
2. 1.の結果を1bit右シフト。これを桁あふれが1になるまで繰り返す
3. 2.の結果とA001hのXORを計算
4. シフトが8回になるまで2.と3.を繰り返す
5. 4.の結果と次のアドレス(8ビット)のXORを計算。すべてのバイトに対して2.から4.を繰り返す。最後の計算結果がCRC-16の計算結果となる。

## Arduinoとのシリアル通信
ドライバとは別にシリアル通信でマイコン(Arduino)と通信する。
マイコンに1byteのクエリを送信することで、マイコンはセンサ値を読み2byteごとに値を設定する。
送信されるレスポンスはヘッダ(0xFF) + データ(2byteごとの値) + チェックサム(データの合計値 & 0xFFの1byte)となる。
