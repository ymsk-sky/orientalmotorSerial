# ModbusによるPLC経由でのモータ制御
オリエンタルモーターAZシリーズをシリアルで動作させる。


# ModbusTest.py
コピペしました。
Qiita [Modbusを使ってPLC経由でモータを制御する](https://qiita.com/ToyoshiMorioka/items/8f92121f6bf6b9b6d9a0)

## 使い方
1. git clone
2. pip install pyserial
3. python ModbusTest.py

COMポートは都度書き換えること。

# py_control.py
メイン。 → robot_contorol.pyに移行。
モータードライバとマイコンと同時にシリアル通信を行なう。
マイコンとの通信によってセンサ値をreadしその値に応じてモーターの回転角度を決定する。
モーターは動作前に状態の確認を行ない、動作中であれば待機、動作可能になるとクエリ作成・書き込み・レスポンス読み出し、の処理を行なう。

## ダイレクトデータ運転
通常運転より操作できるパラメータが少ないが、書き込みと同時に動作開始する。
パラメータは以下の7項目。
- データNo.
- 方式
- 位置
- 速度
- 起動・変速レート
- 停止レート
- 運転電流

## ドライバ出力状態
ドライバI/Oの出力状態を取得しその値に応じて動作を変更する。

### CRC-16/Modbusの計算
実装しました。以下アルゴリズム。

1. 初期値をFFFFhとし、FFFFhと最初のアドレス(8ビット)の排他的論理和(XOR)を計算
2. 1.の結果を1bit右シフト。これを桁あふれが1になるまで繰り返す
3. 2.の結果とA001hのXORを計算
4. シフトが8回になるまで2.と3.を繰り返す
5. 4.の結果と次のアドレス(8ビット)のXORを計算。すべてのバイトに対して2.から4.を繰り返す。最後の計算結果がCRC-16の計算結果となる。

## Arduinoとのシリアル通信
ドライバとは別にシリアル通信でマイコン(Arduino)と通信する。
マイコンに1byteのクエリを送信することで、マイコンはセンサ値を読み2byteごとに値を設定する。
送信されるレスポンスはヘッダ(0xFF) + データ(2byteごとの値) + チェックサム(データの合計値 & 0xFFの1byte)となる。

# robot_control.py
更新点
- 電磁ブレーキの制御
- シリアル通信で受け取るデータのマイナス値に対応
- 制御量を表で持つ(未実装)
- エラー処理(未実装)
